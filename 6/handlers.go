package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"image"
	"image/jpeg"
	"image/png"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/mangirdaz/api-skeleton/config"
)

const NotFound = "Not found"

type AutoGenerated struct {
	Month      string `json:"month"`
	Num        int    `json:"num"`
	Link       string `json:"link"`
	Year       string `json:"year"`
	News       string `json:"news"`
	SafeTitle  string `json:"safe_title"`
	Transcript string `json:"transcript"`
	Alt        string `json:"alt"`
	Img        string `json:"img"`
	Title      string `json:"title"`
	Day        string `json:"day"`
}

//Health endpoit for app server
func (s *Server) Health(w http.ResponseWriter, r *http.Request) {
	log.Debug("/health endpoint called")

	log.Debug("Add counter to KVStorage")
	count, err := s.kv.Get("counter-health")
	if err != nil {
		log.Debug("default 0")
		s.kv.Put("counter-health", []byte("0"))
	}
	count, err = s.kv.Get("counter-health")
	countNew, err := strconv.Atoi(string(count.Value[:]))
	if err == nil {
		countNew++
		s.kv.Put("counter-health", []byte(strconv.Itoa(countNew)))
	}

	w.Write([]byte("OK"))
}

//Index endpoit for app server
func (s *Server) Index(resp http.ResponseWriter, req *http.Request) {
	log.Debug("/ endpoint called")
	//http://xkcd.com/xxxx/info.0.json

	log.Debug("Add counter to KVStorage")
	count, err := s.kv.Get("counter")
	if err != nil {
		log.Debug("default 0")
		s.kv.Put("counter", []byte("0"))
	}
	count, err = s.kv.Get("counter")
	countNew, err := strconv.Atoi(string(count.Value[:]))
	if err == nil {
		countNew++
		s.kv.Put("counter", []byte(strconv.Itoa(countNew)))
	}

	xkcdURL := fmt.Sprintf("%s%d%s", "http://xkcd.com/", random(1, 999), "/info.0.json")
	log.Debugf("Getting random xkcd [%s]", xkcdURL)
	payload, err := http.Get(xkcdURL)
	img := AutoGenerated{}
	if err != nil {
		log.Errorf("Error while calling %s", xkcdURL)
		log.Error(err.Error())
	} else {
		defer req.Body.Close()
		json.NewDecoder(payload.Body).Decode(&img)

		log.Debugf("Getting image %s", img.Img)
		response, _ := http.Get(img.Img)
		defer response.Body.Close()
		image, _, err := image.Decode(response.Body)
		if err != nil {
			log.Errorf("Error while decoding %s", img.Img)
		} else {
			log.Debugf("Decoding image %s", img.Img)
		}

		buffer := new(bytes.Buffer)

		if strings.ContainsAny(img.Img, ".png") {

			if err := png.Encode(buffer, image); err != nil {
				log.Println("unable to encode image.")
			}

			resp.Header().Set("Content-Type", "image/png")
			resp.Header().Set("Content-Length", strconv.Itoa(len(buffer.Bytes())))
			if _, err := resp.Write(buffer.Bytes()); err != nil {
				log.Println("unable to write image.")
			}

		} else {

			if err := jpeg.Encode(buffer, image, nil); err != nil {
				log.Println("unable to encode image.")
			}

			resp.Header().Set("Content-Type", "image/jpeg")
			resp.Header().Set("Content-Length", strconv.Itoa(len(buffer.Bytes())))
			if _, err := resp.Write(buffer.Bytes()); err != nil {
				log.Println("unable to write image.")
			}
		}

	}
}

//Index endpoit for app server
func (s *Server) Counter(resp http.ResponseWriter, req *http.Request) {
	log.Debug("/counter endpoint called")
	//http://xkcd.com/xxxx/info.0.json

	log.Debug("Get counter from KVStorage")
	count, err := s.kv.Get("counter")
	if err == nil {
		resp.Write([]byte("Image Counter\n"))
		resp.Write(count.Value)
		resp.Write([]byte("\n"))
	}
	count, err = s.kv.Get("counter-health")
	if err == nil {
		resp.Write([]byte("Health Counter\n"))
		resp.Write(count.Value)
	}

}

func random(min, max int) int {
	rand.Seed(time.Now().Unix())
	return rand.Intn(max-min) + min
}

func CheckAuth(resp http.ResponseWriter, req *http.Request, next http.HandlerFunc) {
	log.Info("Check auth Middleware")
	user, pass, _ := req.BasicAuth()
	enabled, _ := strconv.ParseBool(config.Get("EnvBasicAuth"))
	log.WithFields(log.Fields{
		"auth": enabled,
	}).Debug("handler")
	if enabled && !checkPass(user, pass) {
		reason := "Unauthorized"
		resp.WriteHeader(http.StatusUnauthorized)
		response(reason, true, nil, resp, req)
		return
	}
	next(resp, req)
}

func checkPass(user, pass string) bool {
	log.Info(fmt.Sprintf("User [%s] and Pass [%s]", user, pass))
	if user == "admin" && pass == "admin" {
		log.Info("Pass OK")
		return true
	} else {
		log.Info("Pass Error")
		return false
	}
	return false
}

func CorsHeadersMiddleware(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	log.Info("Cors Middleware")
	rw.Header().Set("Access-Control-Allow-Origin", "*")
	rw.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
	rw.Header().Set("Access-Control-Allow-Headers",
		"Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

	rw.Header().Set("Access-Control-Expose-Headers", "Authorization")
	rw.Header().Set("Access-Control-Request-Headers", "Authorization")

	if r.Method == "OPTIONS" {
		rw.WriteHeader(200)
		return
	}

	next(rw, r)
}

func response(obj interface{}, prettyPrint bool, err error, resp http.ResponseWriter, req *http.Request) {
	// Check for an error
HAS_ERR:
	if err != nil {

		if err.Error() == NotFound {
			resp.WriteHeader(http.StatusNotFound)
			return
		}

		log.WithFields(log.Fields{
			"error":  err,
			"method": req.Method,
			"url":    req.URL,
		}).Error("request error")

		code := 500
		errMsg := err.Error()
		if strings.Contains(errMsg, "Permission denied") || strings.Contains(errMsg, "ACL not found") {
			code = 403
		}
		resp.WriteHeader(code)
		resp.Write([]byte(err.Error()))
		return
	}

	// Write out the JSON object
	if obj != nil {
		buf, err := marshall(obj, true)
		if err != nil {
			goto HAS_ERR
		}
		resp.Header().Set("Content-Type", "application/json")

		// encoding/json library has a specific bug(feature) to turn empty slices into json null object,
		// let's make an empty array instead
		if string(buf) == "null" {
			buf = []byte("[]")
		}
		resp.Write(buf)
	}
}

// marshall returns a json byte slice, leaving existing json untouched.
func marshall(obj interface{}, pretty bool) ([]byte, error) {

	var js interface{}
	var buf []byte

	// Only check objects that byte slices and strings for valid json
	switch v := obj.(type) {
	case []byte:
		buf = []byte(v)
	case string:
		buf = []byte(v)
	}

	// If we were given a valid json object, return it as-is
	if buf != nil && json.Unmarshal(buf, &js) == nil {
		return buf, nil
	}

	// Otherwise marshall the object into json
	if pretty {
		return json.MarshalIndent(obj, "", "    ")
	}
	return json.Marshal(obj)
}
